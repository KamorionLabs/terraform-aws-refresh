{
  "Comment": "Monitors EFS cross-account replication sync status with lazy Lambda creation. Creates context-specific Lambdas on first use, reuses them on subsequent runs.",
  "StartAt": "InitializeState",
  "States": {
    "InitializeState": {
      "Type": "Pass",
      "Comment": "Initialize state and build Lambda names based on context",
      "Parameters": {
        "SourceFileSystemId.$": "$.SourceFileSystemId",
        "DestinationFileSystemId.$": "$.DestinationFileSystemId",
        "SourceAccount.$": "$.SourceAccount",
        "DestinationAccount.$": "$.DestinationAccount",
        "Context.$": "$.Context",
        "LambdaConfig.$": "$.LambdaConfig",
        "WaitSeconds": 60,
        "MaxWaitCount": 60,
        "WaitCount": 0,
        "Mode.$": "States.ArrayGetItem(States.Array($.Mode, 'wait'), 0)",
        "SourceLambdaName.$": "States.Format('{}-check-flag-file-{}', $.LambdaConfig.SourceLambdaPrefix, $.Context)",
        "DestinationLambdaName.$": "States.Format('{}-check-flag-file-{}', $.LambdaConfig.DestinationLambdaPrefix, $.Context)"
      },
      "Next": "GetReplicationStatus"
    },
    "GetReplicationStatus": {
      "Type": "Task",
      "Resource": "arn:aws:states:::aws-sdk:efs:describeReplicationConfigurations",
      "Parameters": {
        "FileSystemId.$": "$.SourceFileSystemId"
      },
      "Credentials": {
        "RoleArn.$": "$.SourceAccount.RoleArn"
      },
      "ResultPath": "$.ReplicationStatus",
      "Next": "CheckReplicationState",
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.Error",
          "Next": "CheckFailed"
        }
      ]
    },
    "CheckReplicationState": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.ReplicationStatus.Replications[0].Destinations[0].Status",
          "StringEquals": "ENABLED",
          "Next": "CheckLastSyncTime"
        },
        {
          "Variable": "$.ReplicationStatus.Replications[0].Destinations[0].Status",
          "StringEquals": "ENABLING",
          "Next": "HandleEnablingState"
        },
        {
          "Variable": "$.ReplicationStatus.Replications[0].Destinations[0].Status",
          "StringEquals": "ERROR",
          "Next": "ReplicationError"
        },
        {
          "Variable": "$.ReplicationStatus.Replications[0].Destinations[0].Status",
          "StringEquals": "DELETING",
          "Next": "ReplicationError"
        }
      ],
      "Default": "WaitForReplication"
    },
    "HandleEnablingState": {
      "Type": "Choice",
      "Comment": "In check mode report status, in wait mode keep waiting",
      "Choices": [
        {
          "Variable": "$.Mode",
          "StringEquals": "check",
          "Next": "PrepareEnablingOutput"
        }
      ],
      "Default": "WaitForReplication"
    },
    "PrepareEnablingOutput": {
      "Type": "Pass",
      "Parameters": {
        "Status": "Enabling",
        "ModuleName": "check_replication_sync",
        "SourceFileSystemId.$": "$.SourceFileSystemId",
        "DestinationFileSystemId.$": "$.DestinationFileSystemId",
        "ReplicationState.$": "$.ReplicationStatus.Replications[0].Destinations[0].Status",
        "Message": "Replication is being enabled, initial sync not yet started"
      },
      "Next": "CheckSucceeded"
    },
    "CheckLastSyncTime": {
      "Type": "Choice",
      "Comment": "Check if initial sync has completed by verifying LastReplicatedTimestamp exists",
      "Choices": [
        {
          "Variable": "$.ReplicationStatus.Replications[0].Destinations[0].LastReplicatedTimestamp",
          "IsPresent": true,
          "Next": "CheckFlagFileEnabled"
        }
      ],
      "Default": "HandleNoSyncYet"
    },
    "HandleNoSyncYet": {
      "Type": "Choice",
      "Comment": "In check mode report status, in wait mode keep waiting",
      "Choices": [
        {
          "Variable": "$.Mode",
          "StringEquals": "check",
          "Next": "PrepareNoSyncOutput"
        }
      ],
      "Default": "WaitForReplication"
    },
    "PrepareNoSyncOutput": {
      "Type": "Pass",
      "Parameters": {
        "Status": "Syncing",
        "ModuleName": "check_replication_sync",
        "SourceFileSystemId.$": "$.SourceFileSystemId",
        "DestinationFileSystemId.$": "$.DestinationFileSystemId",
        "ReplicationState.$": "$.ReplicationStatus.Replications[0].Destinations[0].Status",
        "Message": "Initial sync in progress, no LastReplicatedTimestamp yet"
      },
      "Next": "CheckSucceeded"
    },
    "CheckFlagFileEnabled": {
      "Type": "Choice",
      "Comment": "If flag file verification is enabled, proceed with Lambda setup",
      "Choices": [
        {
          "And": [
            {
              "Variable": "$.LambdaConfig.EnableFlagFileCheck",
              "IsPresent": true
            },
            {
              "Variable": "$.LambdaConfig.EnableFlagFileCheck",
              "BooleanEquals": true
            }
          ],
          "Next": "GenerateFlagId"
        }
      ],
      "Default": "PrepareOutputNoFlagCheck"
    },
    "PrepareOutputNoFlagCheck": {
      "Type": "Pass",
      "Parameters": {
        "Status": "Synced",
        "ModuleName": "check_replication_sync",
        "SourceFileSystemId.$": "$.SourceFileSystemId",
        "DestinationFileSystemId.$": "$.ReplicationStatus.Replications[0].Destinations[0].FileSystemId",
        "LastReplicatedTimestamp.$": "$.ReplicationStatus.Replications[0].Destinations[0].LastReplicatedTimestamp",
        "FlagFileVerified": false,
        "Message": "Replication sync confirmed via API (flag file check disabled)"
      },
      "Next": "CheckSucceeded"
    },
    "GenerateFlagId": {
      "Type": "Pass",
      "Parameters": {
        "SourceFileSystemId.$": "$.SourceFileSystemId",
        "DestinationFileSystemId.$": "$.DestinationFileSystemId",
        "SourceAccount.$": "$.SourceAccount",
        "DestinationAccount.$": "$.DestinationAccount",
        "Context.$": "$.Context",
        "LambdaConfig.$": "$.LambdaConfig",
        "SourceLambdaName.$": "$.SourceLambdaName",
        "DestinationLambdaName.$": "$.DestinationLambdaName",
        "WaitSeconds.$": "$.WaitSeconds",
        "MaxWaitCount.$": "$.MaxWaitCount",
        "WaitCount.$": "$.WaitCount",
        "Mode.$": "$.Mode",
        "ReplicationStatus.$": "$.ReplicationStatus",
        "FlagId.$": "States.UUID()",
        "FlagRetryCount": 0,
        "MaxFlagRetries": 15
      },
      "Next": "EnsureSourceLambdaExists"
    },
    "EnsureSourceLambdaExists": {
      "Type": "Task",
      "Resource": "arn:aws:states:::aws-sdk:lambda:getFunction",
      "Parameters": {
        "FunctionName.$": "$.SourceLambdaName"
      },
      "Credentials": {
        "RoleArn.$": "$.SourceAccount.RoleArn"
      },
      "ResultPath": "$.SourceLambdaInfo",
      "Next": "CreateSourceAccessPoint",
      "Catch": [
        {
          "ErrorEquals": ["Lambda.ResourceNotFoundException"],
          "ResultPath": "$.SourceLambdaNotFound",
          "Next": "CreateSourceLambda"
        },
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.Error",
          "Next": "CheckFailed"
        }
      ]
    },
    "CreateSourceLambda": {
      "Type": "Task",
      "Resource": "arn:aws:states:::aws-sdk:lambda:createFunction",
      "Parameters": {
        "FunctionName.$": "$.SourceLambdaName",
        "Runtime": "python3.11",
        "Handler": "check_flag_file.lambda_handler",
        "Role.$": "$.LambdaConfig.SourceLambdaRoleArn",
        "Code": {
          "S3Bucket.$": "$.LambdaConfig.CodeS3Bucket",
          "S3Key.$": "$.LambdaConfig.CodeS3Key"
        },
        "Timeout": 60,
        "MemorySize": 128,
        "Architectures": ["arm64"],
        "VpcConfig": {
          "SubnetIds.$": "$.LambdaConfig.SourceSubnetIds",
          "SecurityGroupIds.$": "$.LambdaConfig.SourceSecurityGroupIds"
        },
        "Environment": {
          "Variables": {
            "LOG_LEVEL": "INFO",
            "EFS_MOUNT_PATH": "/mnt/efs"
          }
        },
        "Tags": {
          "ManagedBy": "StepFunctions",
          "Context.$": "$.Context",
          "Purpose": "EFS-FlagFile-Check"
        }
      },
      "Credentials": {
        "RoleArn.$": "$.SourceAccount.RoleArn"
      },
      "ResultPath": "$.CreatedSourceLambda",
      "Next": "WaitSourceLambdaReady",
      "Catch": [
        {
          "ErrorEquals": ["Lambda.ResourceConflictException"],
          "ResultPath": "$.SourceLambdaConflict",
          "Comment": "Lambda already exists (race condition), continue",
          "Next": "CreateSourceAccessPoint"
        },
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.Error",
          "Next": "CheckFailed"
        }
      ]
    },
    "WaitSourceLambdaReady": {
      "Type": "Wait",
      "Seconds": 5,
      "Next": "CreateSourceAccessPoint"
    },
    "CreateSourceAccessPoint": {
      "Type": "Task",
      "Resource": "arn:aws:states:::aws-sdk:efs:createAccessPoint",
      "Parameters": {
        "ClientToken.$": "States.Format('src-{}-{}', $.Context, $.FlagId)",
        "FileSystemId.$": "$.SourceFileSystemId",
        "PosixUser": {
          "Uid": 0,
          "Gid": 0
        },
        "RootDirectory": {
          "Path": "/",
          "CreationInfo": {
            "OwnerUid": 0,
            "OwnerGid": 0,
            "Permissions": "755"
          }
        },
        "Tags": [
          {
            "Key": "Name",
            "Value.$": "States.Format('temp-flag-check-{}', $.FlagId)"
          },
          {
            "Key": "ManagedBy",
            "Value": "StepFunctions"
          },
          {
            "Key": "Purpose",
            "Value": "FlagFileCheck"
          }
        ]
      },
      "Credentials": {
        "RoleArn.$": "$.SourceAccount.RoleArn"
      },
      "ResultPath": "$.SourceAccessPoint",
      "Next": "WaitSourceAccessPoint",
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.Error",
          "Next": "CheckFailed"
        }
      ]
    },
    "WaitSourceAccessPoint": {
      "Type": "Wait",
      "Seconds": 5,
      "Next": "DescribeSourceAccessPoint"
    },
    "DescribeSourceAccessPoint": {
      "Type": "Task",
      "Resource": "arn:aws:states:::aws-sdk:efs:describeAccessPoints",
      "Parameters": {
        "AccessPointId.$": "$.SourceAccessPoint.AccessPointId"
      },
      "Credentials": {
        "RoleArn.$": "$.SourceAccount.RoleArn"
      },
      "ResultPath": "$.SourceAccessPointStatus",
      "Next": "IsSourceAccessPointAvailable"
    },
    "IsSourceAccessPointAvailable": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.SourceAccessPointStatus.AccessPoints[0].LifeCycleState",
          "StringEquals": "available",
          "Next": "UpdateSourceLambdaConfig"
        }
      ],
      "Default": "WaitSourceAccessPoint"
    },
    "UpdateSourceLambdaConfig": {
      "Type": "Task",
      "Resource": "arn:aws:states:::aws-sdk:lambda:updateFunctionConfiguration",
      "Parameters": {
        "FunctionName.$": "$.SourceLambdaName",
        "FileSystemConfigs": [
          {
            "Arn.$": "$.SourceAccessPoint.AccessPointArn",
            "LocalMountPath": "/mnt/efs"
          }
        ]
      },
      "Credentials": {
        "RoleArn.$": "$.SourceAccount.RoleArn"
      },
      "ResultPath": null,
      "Next": "WaitSourceLambdaUpdate",
      "Retry": [
        {
          "ErrorEquals": ["Lambda.ResourceConflictException"],
          "IntervalSeconds": 5,
          "MaxAttempts": 10,
          "BackoffRate": 1.5
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.SourceLambdaUpdateError",
          "Next": "CleanupSourceAccessPoint"
        }
      ]
    },
    "WaitSourceLambdaUpdate": {
      "Type": "Wait",
      "Seconds": 10,
      "Next": "EnsureDestinationLambdaExists"
    },
    "EnsureDestinationLambdaExists": {
      "Type": "Task",
      "Resource": "arn:aws:states:::aws-sdk:lambda:getFunction",
      "Parameters": {
        "FunctionName.$": "$.DestinationLambdaName"
      },
      "Credentials": {
        "RoleArn.$": "$.DestinationAccount.RoleArn"
      },
      "ResultPath": "$.DestinationLambdaInfo",
      "Next": "CreateDestinationAccessPoint",
      "Catch": [
        {
          "ErrorEquals": ["Lambda.ResourceNotFoundException"],
          "ResultPath": "$.DestinationLambdaNotFound",
          "Next": "CreateDestinationLambda"
        },
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.Error",
          "Next": "CleanupSourceAccessPoint"
        }
      ]
    },
    "CreateDestinationLambda": {
      "Type": "Task",
      "Resource": "arn:aws:states:::aws-sdk:lambda:createFunction",
      "Parameters": {
        "FunctionName.$": "$.DestinationLambdaName",
        "Runtime": "python3.11",
        "Handler": "check_flag_file.lambda_handler",
        "Role.$": "$.LambdaConfig.DestinationLambdaRoleArn",
        "Code": {
          "S3Bucket.$": "$.LambdaConfig.CodeS3Bucket",
          "S3Key.$": "$.LambdaConfig.CodeS3Key"
        },
        "Timeout": 60,
        "MemorySize": 128,
        "Architectures": ["arm64"],
        "VpcConfig": {
          "SubnetIds.$": "$.LambdaConfig.DestinationSubnetIds",
          "SecurityGroupIds.$": "$.LambdaConfig.DestinationSecurityGroupIds"
        },
        "Environment": {
          "Variables": {
            "LOG_LEVEL": "INFO",
            "EFS_MOUNT_PATH": "/mnt/efs"
          }
        },
        "Tags": {
          "ManagedBy": "StepFunctions",
          "Context.$": "$.Context",
          "Purpose": "EFS-FlagFile-Check"
        }
      },
      "Credentials": {
        "RoleArn.$": "$.DestinationAccount.RoleArn"
      },
      "ResultPath": "$.CreatedDestinationLambda",
      "Next": "WaitDestinationLambdaReady",
      "Catch": [
        {
          "ErrorEquals": ["Lambda.ResourceConflictException"],
          "ResultPath": "$.DestinationLambdaConflict",
          "Comment": "Lambda already exists (race condition), continue",
          "Next": "CreateDestinationAccessPoint"
        },
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.Error",
          "Next": "CleanupSourceAccessPoint"
        }
      ]
    },
    "WaitDestinationLambdaReady": {
      "Type": "Wait",
      "Seconds": 5,
      "Next": "CreateDestinationAccessPoint"
    },
    "CreateDestinationAccessPoint": {
      "Type": "Task",
      "Resource": "arn:aws:states:::aws-sdk:efs:createAccessPoint",
      "Parameters": {
        "ClientToken.$": "States.Format('dst-{}-{}', $.Context, $.FlagId)",
        "FileSystemId.$": "$.DestinationFileSystemId",
        "PosixUser": {
          "Uid": 0,
          "Gid": 0
        },
        "RootDirectory": {
          "Path": "/",
          "CreationInfo": {
            "OwnerUid": 0,
            "OwnerGid": 0,
            "Permissions": "755"
          }
        },
        "Tags": [
          {
            "Key": "Name",
            "Value.$": "States.Format('temp-flag-check-{}', $.FlagId)"
          },
          {
            "Key": "ManagedBy",
            "Value": "StepFunctions"
          },
          {
            "Key": "Purpose",
            "Value": "FlagFileCheck"
          }
        ]
      },
      "Credentials": {
        "RoleArn.$": "$.DestinationAccount.RoleArn"
      },
      "ResultPath": "$.DestinationAccessPoint",
      "Next": "WaitDestinationAccessPoint",
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.Error",
          "Next": "CleanupSourceAccessPoint"
        }
      ]
    },
    "WaitDestinationAccessPoint": {
      "Type": "Wait",
      "Seconds": 5,
      "Next": "DescribeDestinationAccessPoint"
    },
    "DescribeDestinationAccessPoint": {
      "Type": "Task",
      "Resource": "arn:aws:states:::aws-sdk:efs:describeAccessPoints",
      "Parameters": {
        "AccessPointId.$": "$.DestinationAccessPoint.AccessPointId"
      },
      "Credentials": {
        "RoleArn.$": "$.DestinationAccount.RoleArn"
      },
      "ResultPath": "$.DestinationAccessPointStatus",
      "Next": "IsDestinationAccessPointAvailable"
    },
    "IsDestinationAccessPointAvailable": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.DestinationAccessPointStatus.AccessPoints[0].LifeCycleState",
          "StringEquals": "available",
          "Next": "UpdateDestinationLambdaConfig"
        }
      ],
      "Default": "WaitDestinationAccessPoint"
    },
    "UpdateDestinationLambdaConfig": {
      "Type": "Task",
      "Resource": "arn:aws:states:::aws-sdk:lambda:updateFunctionConfiguration",
      "Parameters": {
        "FunctionName.$": "$.DestinationLambdaName",
        "FileSystemConfigs": [
          {
            "Arn.$": "$.DestinationAccessPoint.AccessPointArn",
            "LocalMountPath": "/mnt/efs"
          }
        ]
      },
      "Credentials": {
        "RoleArn.$": "$.DestinationAccount.RoleArn"
      },
      "ResultPath": null,
      "Next": "WaitDestinationLambdaUpdate",
      "Retry": [
        {
          "ErrorEquals": ["Lambda.ResourceConflictException"],
          "IntervalSeconds": 5,
          "MaxAttempts": 10,
          "BackoffRate": 1.5
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.DestinationLambdaUpdateError",
          "Next": "CleanupAllAccessPoints"
        }
      ]
    },
    "WaitDestinationLambdaUpdate": {
      "Type": "Wait",
      "Seconds": 10,
      "Next": "WriteFlagFileSource"
    },
    "WriteFlagFileSource": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName.$": "$.SourceLambdaName",
        "Payload": {
          "action": "write",
          "flag_id.$": "$.FlagId"
        }
      },
      "Credentials": {
        "RoleArn.$": "$.SourceAccount.RoleArn"
      },
      "ResultSelector": {
        "StatusCode.$": "$.Payload.statusCode",
        "Body.$": "States.StringToJson($.Payload.body)"
      },
      "ResultPath": "$.WriteFlagResult",
      "Next": "VerifyFlagWriteSuccess",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ResourceNotReadyException",
            "Lambda.EFSMountFailureException",
            "Lambda.EFSMountConnectivityException"
          ],
          "IntervalSeconds": 10,
          "MaxAttempts": 6,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.FlagError",
          "Next": "CleanupAllAccessPoints"
        }
      ]
    },
    "VerifyFlagWriteSuccess": {
      "Type": "Choice",
      "Comment": "Verify that flag file was written successfully before waiting for propagation",
      "Choices": [
        {
          "Variable": "$.WriteFlagResult.StatusCode",
          "NumericEquals": 200,
          "Next": "RecordFlagWriteTime"
        }
      ],
      "Default": "FlagWriteFailed"
    },
    "RecordFlagWriteTime": {
      "Type": "Pass",
      "Comment": "Record timestamp when flag file was written to source EFS",
      "Parameters": {
        "SourceFileSystemId.$": "$.SourceFileSystemId",
        "DestinationFileSystemId.$": "$.DestinationFileSystemId",
        "SourceAccount.$": "$.SourceAccount",
        "DestinationAccount.$": "$.DestinationAccount",
        "Context.$": "$.Context",
        "LambdaConfig.$": "$.LambdaConfig",
        "SourceLambdaName.$": "$.SourceLambdaName",
        "DestinationLambdaName.$": "$.DestinationLambdaName",
        "WaitSeconds.$": "$.WaitSeconds",
        "MaxWaitCount.$": "$.MaxWaitCount",
        "WaitCount.$": "$.WaitCount",
        "Mode.$": "$.Mode",
        "ReplicationStatus.$": "$.ReplicationStatus",
        "FlagId.$": "$.FlagId",
        "FlagRetryCount.$": "$.FlagRetryCount",
        "MaxFlagRetries.$": "$.MaxFlagRetries",
        "SourceAccessPoint.$": "$.SourceAccessPoint",
        "DestinationAccessPoint.$": "$.DestinationAccessPoint",
        "WriteFlagResult.$": "$.WriteFlagResult",
        "FlagWriteTimestamp.$": "$$.State.EnteredTime"
      },
      "Next": "WaitForFlagPropagation"
    },
    "FlagWriteFailed": {
      "Type": "Pass",
      "Parameters": {
        "SourceFileSystemId.$": "$.SourceFileSystemId",
        "DestinationFileSystemId.$": "$.DestinationFileSystemId",
        "SourceAccount.$": "$.SourceAccount",
        "DestinationAccount.$": "$.DestinationAccount",
        "SourceAccessPoint.$": "$.SourceAccessPoint",
        "DestinationAccessPoint.$": "$.DestinationAccessPoint",
        "FlagWriteError": {
          "StatusCode.$": "$.WriteFlagResult.StatusCode",
          "Body.$": "$.WriteFlagResult.Body"
        }
      },
      "Next": "CleanupAndFailOnWriteError"
    },
    "CleanupAndFailOnWriteError": {
      "Type": "Parallel",
      "Comment": "Cleanup access points then fail",
      "Branches": [
        {
          "StartAt": "DeleteSourceAPOnWriteError",
          "States": {
            "DeleteSourceAPOnWriteError": {
              "Type": "Task",
              "Resource": "arn:aws:states:::aws-sdk:efs:deleteAccessPoint",
              "Parameters": {
                "AccessPointId.$": "$.SourceAccessPoint.AccessPointId"
              },
              "Credentials": {
                "RoleArn.$": "$.SourceAccount.RoleArn"
              },
              "End": true,
              "Catch": [
                {
                  "ErrorEquals": ["States.ALL"],
                  "Next": "SourceAPDeleteFailedOnWrite"
                }
              ]
            },
            "SourceAPDeleteFailedOnWrite": {
              "Type": "Pass",
              "End": true
            }
          }
        },
        {
          "StartAt": "DeleteDestinationAPOnWriteError",
          "States": {
            "DeleteDestinationAPOnWriteError": {
              "Type": "Task",
              "Resource": "arn:aws:states:::aws-sdk:efs:deleteAccessPoint",
              "Parameters": {
                "AccessPointId.$": "$.DestinationAccessPoint.AccessPointId"
              },
              "Credentials": {
                "RoleArn.$": "$.DestinationAccount.RoleArn"
              },
              "End": true,
              "Catch": [
                {
                  "ErrorEquals": ["States.ALL"],
                  "Next": "DestinationAPDeleteFailedOnWrite"
                }
              ]
            },
            "DestinationAPDeleteFailedOnWrite": {
              "Type": "Pass",
              "End": true
            }
          }
        }
      ],
      "ResultPath": null,
      "Next": "FlagWriteCheckFailed"
    },
    "FlagWriteCheckFailed": {
      "Type": "Fail",
      "Error": "FlagWriteFailed",
      "Cause": "Failed to write flag file to source EFS - check Lambda permissions and EFS access point configuration"
    },
    "WaitForFlagPropagation": {
      "Type": "Wait",
      "Seconds": 120,
      "Next": "CheckFlagFileDestination"
    },
    "CheckFlagFileDestination": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName.$": "$.DestinationLambdaName",
        "Payload": {
          "action": "check",
          "flag_id.$": "$.FlagId",
          "timeout_seconds": 600
        }
      },
      "Credentials": {
        "RoleArn.$": "$.DestinationAccount.RoleArn"
      },
      "ResultSelector": {
        "StatusCode.$": "$.Payload.statusCode",
        "Body.$": "States.StringToJson($.Payload.body)"
      },
      "ResultPath": "$.CheckFlagResult",
      "Next": "EvaluateFlagSync",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ResourceNotReadyException",
            "Lambda.EFSMountFailureException",
            "Lambda.EFSMountConnectivityException"
          ],
          "IntervalSeconds": 10,
          "MaxAttempts": 6,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.FlagError",
          "Next": "CleanupAllAccessPointsAfterWrite"
        }
      ]
    },
    "EvaluateFlagSync": {
      "Type": "Choice",
      "Comment": "Check if flag file was replicated",
      "Choices": [
        {
          "And": [
            {
              "Variable": "$.CheckFlagResult.Body.exists",
              "BooleanEquals": true
            },
            {
              "Variable": "$.CheckFlagResult.Body.valid",
              "BooleanEquals": true
            }
          ],
          "Next": "RecordFlagDetectedTime"
        },
        {
          "Variable": "$.FlagRetryCount",
          "NumericLessThanPath": "$.MaxFlagRetries",
          "Next": "IncrementFlagRetry"
        }
      ],
      "Default": "FlagSyncTimeout"
    },
    "RecordFlagDetectedTime": {
      "Type": "Pass",
      "Comment": "Record timestamp when flag file was detected on destination EFS",
      "Parameters": {
        "SourceFileSystemId.$": "$.SourceFileSystemId",
        "DestinationFileSystemId.$": "$.DestinationFileSystemId",
        "SourceAccount.$": "$.SourceAccount",
        "DestinationAccount.$": "$.DestinationAccount",
        "Context.$": "$.Context",
        "LambdaConfig.$": "$.LambdaConfig",
        "SourceLambdaName.$": "$.SourceLambdaName",
        "DestinationLambdaName.$": "$.DestinationLambdaName",
        "Mode.$": "$.Mode",
        "ReplicationStatus.$": "$.ReplicationStatus",
        "FlagId.$": "$.FlagId",
        "FlagRetryCount.$": "$.FlagRetryCount",
        "SourceAccessPoint.$": "$.SourceAccessPoint",
        "DestinationAccessPoint.$": "$.DestinationAccessPoint",
        "CheckFlagResult.$": "$.CheckFlagResult",
        "FlagWriteTimestamp.$": "$.FlagWriteTimestamp",
        "FlagDetectedTimestamp.$": "$$.State.EnteredTime"
      },
      "Next": "CleanupFlagFiles"
    },
    "IncrementFlagRetry": {
      "Type": "Pass",
      "Parameters": {
        "SourceFileSystemId.$": "$.SourceFileSystemId",
        "DestinationFileSystemId.$": "$.DestinationFileSystemId",
        "SourceAccount.$": "$.SourceAccount",
        "DestinationAccount.$": "$.DestinationAccount",
        "Context.$": "$.Context",
        "LambdaConfig.$": "$.LambdaConfig",
        "SourceLambdaName.$": "$.SourceLambdaName",
        "DestinationLambdaName.$": "$.DestinationLambdaName",
        "WaitSeconds.$": "$.WaitSeconds",
        "MaxWaitCount.$": "$.MaxWaitCount",
        "WaitCount.$": "$.WaitCount",
        "Mode.$": "$.Mode",
        "ReplicationStatus.$": "$.ReplicationStatus",
        "FlagId.$": "$.FlagId",
        "WriteFlagResult.$": "$.WriteFlagResult",
        "SourceAccessPoint.$": "$.SourceAccessPoint",
        "DestinationAccessPoint.$": "$.DestinationAccessPoint",
        "FlagRetryCount.$": "States.MathAdd($.FlagRetryCount, 1)",
        "MaxFlagRetries.$": "$.MaxFlagRetries",
        "FlagWriteTimestamp.$": "$.FlagWriteTimestamp"
      },
      "Next": "WaitBeforeFlagRetry"
    },
    "WaitBeforeFlagRetry": {
      "Type": "Wait",
      "Seconds": 60,
      "Next": "CheckFlagFileDestination"
    },
    "FlagSyncTimeout": {
      "Type": "Pass",
      "Parameters": {
        "FlagSyncStatus": "Timeout",
        "FlagId.$": "$.FlagId",
        "FlagRetryCount.$": "$.FlagRetryCount",
        "CheckResult.$": "$.CheckFlagResult.Body"
      },
      "ResultPath": "$.FlagSyncResult",
      "Next": "CleanupAllAccessPointsAfterWrite"
    },
    "CleanupFlagFiles": {
      "Type": "Parallel",
      "Comment": "Clean up flag files from both source and destination",
      "Branches": [
        {
          "StartAt": "DeleteSourceFlag",
          "States": {
            "DeleteSourceFlag": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "FunctionName.$": "$.SourceLambdaName",
                "Payload": {
                  "action": "delete",
                  "flag_id.$": "$.FlagId"
                }
              },
              "Credentials": {
                "RoleArn.$": "$.SourceAccount.RoleArn"
              },
              "Next": "SourceFlagDeleted",
              "Catch": [
                {
                  "ErrorEquals": ["States.ALL"],
                  "Next": "SourceFlagDeleted"
                }
              ]
            },
            "SourceFlagDeleted": {
              "Type": "Pass",
              "End": true
            }
          }
        },
        {
          "StartAt": "DeleteDestinationFlag",
          "States": {
            "DeleteDestinationFlag": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "FunctionName.$": "$.DestinationLambdaName",
                "Payload": {
                  "action": "delete",
                  "flag_id.$": "$.FlagId"
                }
              },
              "Credentials": {
                "RoleArn.$": "$.DestinationAccount.RoleArn"
              },
              "Next": "DestinationFlagDeleted",
              "Catch": [
                {
                  "ErrorEquals": ["States.ALL"],
                  "Next": "DestinationFlagDeleted"
                }
              ]
            },
            "DestinationFlagDeleted": {
              "Type": "Pass",
              "End": true
            }
          }
        }
      ],
      "ResultPath": null,
      "Next": "ListDirectories"
    },
    "ListDirectories": {
      "Type": "Parallel",
      "Comment": "List root directory contents from both source and destination EFS",
      "Branches": [
        {
          "StartAt": "ListSourceDirectory",
          "States": {
            "ListSourceDirectory": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "FunctionName.$": "$.SourceLambdaName",
                "Payload": {
                  "action": "list",
                  "max_files": 100
                }
              },
              "Credentials": {
                "RoleArn.$": "$.SourceAccount.RoleArn"
              },
              "ResultSelector": {
                "StatusCode.$": "$.Payload.statusCode",
                "Body.$": "States.StringToJson($.Payload.body)"
              },
              "End": true,
              "Catch": [
                {
                  "ErrorEquals": ["States.ALL"],
                  "ResultPath": "$.Error",
                  "Next": "SourceListFailed"
                }
              ]
            },
            "SourceListFailed": {
              "Type": "Pass",
              "Parameters": {
                "StatusCode": 500,
                "Body": {
                  "action": "list",
                  "error": "Failed to list source directory"
                }
              },
              "End": true
            }
          }
        },
        {
          "StartAt": "ListDestinationDirectory",
          "States": {
            "ListDestinationDirectory": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "FunctionName.$": "$.DestinationLambdaName",
                "Payload": {
                  "action": "list",
                  "max_files": 100
                }
              },
              "Credentials": {
                "RoleArn.$": "$.DestinationAccount.RoleArn"
              },
              "ResultSelector": {
                "StatusCode.$": "$.Payload.statusCode",
                "Body.$": "States.StringToJson($.Payload.body)"
              },
              "End": true,
              "Catch": [
                {
                  "ErrorEquals": ["States.ALL"],
                  "ResultPath": "$.Error",
                  "Next": "DestinationListFailed"
                }
              ]
            },
            "DestinationListFailed": {
              "Type": "Pass",
              "Parameters": {
                "StatusCode": 500,
                "Body": {
                  "action": "list",
                  "error": "Failed to list destination directory"
                }
              },
              "End": true
            }
          }
        }
      ],
      "ResultPath": "$.DirectoryListings",
      "Next": "CleanupAllAccessPoints"
    },
    "CleanupAllAccessPointsAfterWrite": {
      "Type": "Parallel",
      "Comment": "Cleanup access points and try to delete source flag",
      "Branches": [
        {
          "StartAt": "TryDeleteSourceFlagOnError",
          "States": {
            "TryDeleteSourceFlagOnError": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "FunctionName.$": "$.SourceLambdaName",
                "Payload": {
                  "action": "delete",
                  "flag_id.$": "$.FlagId"
                }
              },
              "Credentials": {
                "RoleArn.$": "$.SourceAccount.RoleArn"
              },
              "End": true,
              "Catch": [
                {
                  "ErrorEquals": ["States.ALL"],
                  "Next": "SourceFlagDeleteFailed"
                }
              ]
            },
            "SourceFlagDeleteFailed": {
              "Type": "Pass",
              "End": true
            }
          }
        },
        {
          "StartAt": "DeleteSourceAPOnError",
          "States": {
            "DeleteSourceAPOnError": {
              "Type": "Task",
              "Resource": "arn:aws:states:::aws-sdk:efs:deleteAccessPoint",
              "Parameters": {
                "AccessPointId.$": "$.SourceAccessPoint.AccessPointId"
              },
              "Credentials": {
                "RoleArn.$": "$.SourceAccount.RoleArn"
              },
              "End": true,
              "Catch": [
                {
                  "ErrorEquals": ["States.ALL"],
                  "Next": "SourceAPDeleteFailed"
                }
              ]
            },
            "SourceAPDeleteFailed": {
              "Type": "Pass",
              "End": true
            }
          }
        },
        {
          "StartAt": "DeleteDestinationAPOnError",
          "States": {
            "DeleteDestinationAPOnError": {
              "Type": "Task",
              "Resource": "arn:aws:states:::aws-sdk:efs:deleteAccessPoint",
              "Parameters": {
                "AccessPointId.$": "$.DestinationAccessPoint.AccessPointId"
              },
              "Credentials": {
                "RoleArn.$": "$.DestinationAccount.RoleArn"
              },
              "End": true,
              "Catch": [
                {
                  "ErrorEquals": ["States.ALL"],
                  "Next": "DestinationAPDeleteFailed"
                }
              ]
            },
            "DestinationAPDeleteFailed": {
              "Type": "Pass",
              "End": true
            }
          }
        }
      ],
      "ResultPath": null,
      "Next": "PrepareOutputAfterTimeout"
    },
    "PrepareOutputAfterTimeout": {
      "Type": "Pass",
      "Parameters": {
        "Status": "Timeout",
        "ModuleName": "check_replication_sync",
        "SourceFileSystemId.$": "$.SourceFileSystemId",
        "DestinationFileSystemId.$": "$.DestinationFileSystemId",
        "FlagId.$": "$.FlagId",
        "Message": "Flag file verification timed out"
      },
      "Next": "CheckSucceeded"
    },
    "CleanupAllAccessPoints": {
      "Type": "Parallel",
      "Comment": "Clean up temporary access points (keep Lambdas for reuse)",
      "Branches": [
        {
          "StartAt": "DeleteSourceAP",
          "States": {
            "DeleteSourceAP": {
              "Type": "Task",
              "Resource": "arn:aws:states:::aws-sdk:efs:deleteAccessPoint",
              "Parameters": {
                "AccessPointId.$": "$.SourceAccessPoint.AccessPointId"
              },
              "Credentials": {
                "RoleArn.$": "$.SourceAccount.RoleArn"
              },
              "End": true,
              "Catch": [
                {
                  "ErrorEquals": ["States.ALL"],
                  "Next": "SourceAPCleanupFailed"
                }
              ]
            },
            "SourceAPCleanupFailed": {
              "Type": "Pass",
              "End": true
            }
          }
        },
        {
          "StartAt": "DeleteDestinationAP",
          "States": {
            "DeleteDestinationAP": {
              "Type": "Task",
              "Resource": "arn:aws:states:::aws-sdk:efs:deleteAccessPoint",
              "Parameters": {
                "AccessPointId.$": "$.DestinationAccessPoint.AccessPointId"
              },
              "Credentials": {
                "RoleArn.$": "$.DestinationAccount.RoleArn"
              },
              "End": true,
              "Catch": [
                {
                  "ErrorEquals": ["States.ALL"],
                  "Next": "DestinationAPCleanupFailed"
                }
              ]
            },
            "DestinationAPCleanupFailed": {
              "Type": "Pass",
              "End": true
            }
          }
        }
      ],
      "ResultPath": null,
      "Next": "PrepareFlagVerifiedOutput"
    },
    "CleanupSourceAccessPoint": {
      "Type": "Task",
      "Resource": "arn:aws:states:::aws-sdk:efs:deleteAccessPoint",
      "Parameters": {
        "AccessPointId.$": "$.SourceAccessPoint.AccessPointId"
      },
      "Credentials": {
        "RoleArn.$": "$.SourceAccount.RoleArn"
      },
      "ResultPath": null,
      "Next": "CheckFailed",
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Next": "CheckFailed"
        }
      ]
    },
    "PrepareFlagVerifiedOutput": {
      "Type": "Pass",
      "Parameters": {
        "Status": "Verified",
        "ModuleName": "check_replication_sync",
        "SourceFileSystemId.$": "$.SourceFileSystemId",
        "DestinationFileSystemId.$": "$.ReplicationStatus.Replications[0].Destinations[0].FileSystemId",
        "FlagFileVerified": true,
        "FlagId.$": "$.FlagId",
        "Context.$": "$.Context",
        "SourceLambdaName.$": "$.SourceLambdaName",
        "DestinationLambdaName.$": "$.DestinationLambdaName",
        "Message": "Replication sync verified with flag file test",
        "ReplicationInfo": {
          "CreationTime.$": "$.ReplicationStatus.Replications[0].CreationTime",
          "Status.$": "$.ReplicationStatus.Replications[0].Destinations[0].Status",
          "LastReplicatedTimestamp.$": "$.ReplicationStatus.Replications[0].Destinations[0].LastReplicatedTimestamp",
          "SourceFileSystemArn.$": "$.ReplicationStatus.Replications[0].SourceFileSystemArn",
          "DestinationFileSystemArn.$": "$.ReplicationStatus.Replications[0].Destinations[0].FileSystemId"
        },
        "PropagationTiming": {
          "FlagWriteTimestamp.$": "$.FlagWriteTimestamp",
          "FlagDetectedTimestamp.$": "$.FlagDetectedTimestamp",
          "FlagRetryCount.$": "$.FlagRetryCount"
        },
        "SourceDirectoryListing.$": "$.DirectoryListings[0].Body",
        "DestinationDirectoryListing.$": "$.DirectoryListings[1].Body"
      },
      "Next": "CheckSucceeded"
    },
    "WaitForReplication": {
      "Type": "Wait",
      "SecondsPath": "$.WaitSeconds",
      "Next": "IncrementCounter"
    },
    "IncrementCounter": {
      "Type": "Pass",
      "Parameters": {
        "SourceFileSystemId.$": "$.SourceFileSystemId",
        "DestinationFileSystemId.$": "$.DestinationFileSystemId",
        "SourceAccount.$": "$.SourceAccount",
        "DestinationAccount.$": "$.DestinationAccount",
        "Context.$": "$.Context",
        "LambdaConfig.$": "$.LambdaConfig",
        "SourceLambdaName.$": "$.SourceLambdaName",
        "DestinationLambdaName.$": "$.DestinationLambdaName",
        "WaitSeconds.$": "$.WaitSeconds",
        "MaxWaitCount.$": "$.MaxWaitCount",
        "WaitCount.$": "States.MathAdd($.WaitCount, 1)",
        "Mode.$": "$.Mode"
      },
      "Next": "CheckTimeout"
    },
    "CheckTimeout": {
      "Type": "Choice",
      "Comment": "Check if we've exceeded maximum wait iterations",
      "Choices": [
        {
          "Variable": "$.WaitCount",
          "NumericGreaterThanPath": "$.MaxWaitCount",
          "Next": "TimeoutReached"
        }
      ],
      "Default": "GetReplicationStatus"
    },
    "TimeoutReached": {
      "Type": "Pass",
      "Parameters": {
        "Status": "Timeout",
        "ModuleName": "check_replication_sync",
        "SourceFileSystemId.$": "$.SourceFileSystemId",
        "DestinationFileSystemId.$": "$.DestinationFileSystemId",
        "WaitCount.$": "$.WaitCount",
        "Message": "Timeout waiting for replication sync"
      },
      "Next": "CheckSucceeded"
    },
    "ReplicationError": {
      "Type": "Fail",
      "Error": "ReplicationError",
      "Cause": "EFS replication is in error or deleting state"
    },
    "CheckFailed": {
      "Type": "Fail",
      "Error": "CheckFailed",
      "Cause": "Failed to check replication status"
    },
    "CheckSucceeded": {
      "Type": "Succeed"
    }
  }
}
